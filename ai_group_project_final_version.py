# -*- coding: utf-8 -*-
"""AI_group_project_final_version.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iq07LSQ1jxRP_-kws41RcCW0eYN6CXUF
"""

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from sentence_transformers import SentenceTransformer
import torch
# Download necessary NLTK resources
nltk.download('punkt', quiet=True)
nltk.download('stopwords', quiet=True)

from google.colab import drive
drive.mount('/content/drive')

def load_data(file_path='/content/drive/MyDrive/36121 AI/AI-Assignment 3-Group/drugs_side_effects_drugs_com.csv'):
  ### load the necessary data
  df = pd.read_csv(file_path)
  # Fill NaN values to avoid processing errors
  df['medical_condition_description'] = df['medical_condition_description'].fillna('')
  df['medical_condition'] = df['medical_condition'].fillna('')
  df['side_effects'] = df['side_effects'].fillna('No known side effects')
  df['pregnancy_category'] = df['pregnancy_category'].fillna('Unknown')
  return df

class SymptomMatcher:
  def __init__(self, df):
    self.df = df
    ### define the stop words to ignore the unused words of the input (such as 'the','and')
    self.stop_words = set(stopwords.words('english'))

    ### split the medical condition description by ';' and expand the list
    self.expanded_conditions = []
    self.index_mapping = []
    self.device = torch.device('cuda' if torch.cuda.is_available else 'cpu')
    for idx, description in enumerate(df['medical_condition_description']):
      parts = [part.strip() for part in str(description).split(';') if part.strip()]
      ### put the all conditions into the emebdding
      self.expanded_conditions.extend(parts)
      self.index_mapping.extend([idx] * len(parts))

    ### load the pre-trained BERT model for sentence embeddings
    self.model = SentenceTransformer('all-MiniLM-L6-v2',device = self.device)

    ### encode all expanded conditions
    self.condition_embeddings = self.model.encode(self.expanded_conditions, normalize_embeddings=True)

  ### define the extract function to extract the users input
  def extract_keywords(self, user_input):
    ### preprocessing the user input
    tokens = word_tokenize(user_input.lower())
    ### extract the keywords that not the stop words and ensure is str
    keywords = [word for word in tokens if word.isalpha() and word not in self.stop_words]
    return keywords

  ### define the function that match the user input's performance and the medical conditions
  def match_condition(self, user_input, threshold=0.4):
    ### encode the user input
    user_input_embedding = self.model.encode([user_input], normalize_embeddings=True)

    ## calculate the similarities between user input and medical symptoms
    similarities = cosine_similarity(user_input_embedding, self.condition_embeddings).flatten()

    ### generate the top 3 matched idx
    top_indices = similarities.argsort()[-3:][::-1]

    ### set the threshold to make the top matched idx
    results = []
    used_indices = set()
    for idx in top_indices:
      if similarities[idx] > threshold:
        original_idx = self.index_mapping[idx]
        if original_idx not in used_indices:
          used_indices.add(original_idx)
          condition = self.df.iloc[original_idx]['medical_condition']

          ### transform the similarities to the 100% number
          confidence = similarities[idx] * 100
          results.append((condition, confidence))

    return results

class DrugRecommender:
  def __init__(self, df):
    self.df = df
    ### prepare drug condition description for semantic search
    self.expanded_conditions = []
    self.index_mapping = []
    ### The same function use to calculate the distance of the sentence in order to recommend drugs
    for idx, description in enumerate(df['medical_condition_description']):
      parts = [part.strip() for part in str(description).split(';') if part.strip()]
      self.expanded_conditions.extend(parts)
      self.index_mapping.extend([idx] * len(parts))
    self.device = torch.device('cuda' if torch.cuda.is_available else 'cpu')
    self.model = SentenceTransformer('all-MiniLM-L6-v2',device=self.device)
    self.condition_embeddings = self.model.encode(self.expanded_conditions, normalize_embeddings=True)

  ## define the function that give the recommended drugs
  def recommend_drugs(self, condition, avoid_alcohol=False,Pregnancy = False, threshold=0.4):
    ### encode the condition
    condition_embedding = self.model.encode([condition], normalize_embeddings=True)

    ## calculate similarities
    similarities = cosine_similarity(condition_embedding, self.condition_embeddings).flatten()
    ### get the top 5 similarities index
    top_indices = similarities.argsort()[-5:][::-1]

    matched_indices = []
    for idx in top_indices:
      if similarities[idx] > threshold:
        matched_indices.append(self.index_mapping[idx])

    if not matched_indices:
      return pd.DataFrame()

    recommendations = self.df.iloc[matched_indices].copy()

    ### set the conditions that filtering the alcohol and transfer to the dataframe
    if avoid_alcohol and 'alcohol' in recommendations.columns:
      recommendations = recommendations[recommendations['alcohol'].isin(['X'])&recommendations['pregnancy_category'].notin(['N','Unknow'])]

    return recommendations

class MedicalChatbot:
  def __init__(self, data_path='/content/drive/MyDrive/36121 AI/AI-Assignment 3-Group/drugs_side_effects_drugs_com.csv'):
    ### load the data
    self.df = load_data(data_path)

    ### initialization the module that previous define
    self.symptom_matcher = SymptomMatcher(self.df)
    self.drug_recommender = DrugRecommender(self.df)

  ## define the function of the query processes
  def process_query(self, user_input, avoid_alcohol=False,Pregnancy = False):
    ### 1. make the user_input to addressing the possible symptoms
    conditions = self.symptom_matcher.match_condition(user_input, threshold=0.4)

    ### set the condition if there matched input not in the conditions
    if not conditions:
      return "I couldn't identify any specific medical condition based on your symptoms. Please consult a healthcare professional for a proper diagnosis."

    ### 2. get the recommended drugs of the most matched disease
    top_condition, confidence = conditions[0]
    response = f"Based on your symptoms, you may have {top_condition} (confidence: {confidence:.1f}%).\n\n"

    drug_recommendations = self.drug_recommender.recommend_drugs(top_condition, avoid_alcohol,Pregnancy)
    if drug_recommendations.empty:
      response += "I couldn't find specific drug recommendations for this condition. Please consult a healthcare professional."
    else:
      response += f"Recommended medications:\n"

      for _, drug in drug_recommendations.iterrows():
        response += f"\n- {drug['drug_name']}"
        if not pd.isna(drug['side_effects']):
          response += f" (Possible side effects: {drug['side_effects']})"
        if not pd.isna(drug['pregnancy_category']):
          response += f" [Pregnancy Category: {drug['pregnancy_category']}]"

    response += '\n\nDisclaimer: This is not a perofessional medical advice. Always consult a healthcare professional before taking any medication.'

    return response

def run_chatbot():
  """Run the chatbot interactive interface"""
  try:
    chatbot = MedicalChatbot()

    print('='*50)
    print('Welcome to the Medical Chatbot!')
    print('Describe your symptoms, and I will try to help.')
    print("Type 'exit' to end the conversation.")
    print('='*50)

    while True:
      user_input = input("\nYour symptoms: ")

      ### set the exit function to support the users to exit our chat box
      if user_input.lower() in ['exit', 'quit', 'bye']:
        print('Thank you for using the Medical Chatbot. Take care!')
        break

      # Ask if user wants to avoid alcohol
      alcohol_input = input("Have you had any alcohol in the past 7 days? (yes/no): ").lower()
      avoid_alcohol = alcohol_input in ['yes', 'y', 'true']
      pregnancy_input = input("Are you female and currently pregnant? (yes/no): ").lower()
      Pregnancy = pregnancy_input in ['yes','y','true']

      # Process query and display results
      try:
        response = chatbot.process_query(user_input, avoid_alcohol)
        print('\n' + response)
      except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("Please try again or consult a healthcare professional.")

  except FileNotFoundError:
    print("Error: Could not find the data file. Please check the file path.")
  except Exception as e:
    print(f"An unexpected error occurred: {e}")

if __name__ == '__main__':
  run_chatbot()